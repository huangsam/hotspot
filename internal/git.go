package internal

import (
	"fmt"
	"os/exec"
	"strings"

	"github.com/stretchr/testify/mock"
)

// GitClient defines the necessary methods for interacting with a Git repository.
// This allows the core analysis logic to be tested without needing a real git executable.
type GitClient interface {
	// Run executes a git command and returns the combined output.
	// It takes the repository path and the git command arguments.
	Run(repoPath string, args ...string) ([]byte, error)
}

// LocalGitClient implements the GitClient interface by executing the
// local 'git' binary installed on the machine.
type LocalGitClient struct{}

// NewLocalGitClient creates a new instance of the local Git client.
func NewLocalGitClient() *LocalGitClient {
	return &LocalGitClient{}
}

// Run executes a git command and returns its combined stdout/stderr output.
func (c *LocalGitClient) Run(repoPath string, args ...string) ([]byte, error) {
	// Prefix the arguments with the -C flag to specify the repository path
	// This makes the git command execution consistent.
	fullArgs := append([]string{"-C", repoPath}, args...)

	cmd := exec.Command("git", fullArgs...)
	out, err := cmd.Output()
	if err != nil {
		// 1. Try to cast the error to *exec.ExitError to get the stderr
		if exitErr, ok := err.(*exec.ExitError); ok && exitErr.Stderr != nil {
			// Extract and clean up the actual error message from Git's stderr
			errMsg := strings.TrimSpace(string(exitErr.Stderr))

			// Wrap the error with context and the Git's stderr output
			return nil, fmt.Errorf("git command '%s' failed: %s: %w", strings.Join(fullArgs, " "), errMsg, err)
		}

		// 2. Handle cases where the command failed to start (e.g., 'git' not found)
		return nil, fmt.Errorf("could not execute git command (is git installed and in PATH?): %w", err)
	}

	return out, nil
}

// MockGitClient is an autogenerated mock type for the GitClient type.
type MockGitClient struct {
	mock.Mock
}

// Run implements the core.GitClient interface.
func (m *MockGitClient) Run(repoPath string, args ...string) ([]byte, error) {
	// The Arguments method records the call and returns the arguments passed.
	// We pass the arguments as an array: {repoPath, args...}

	// Convert variadic args to an interface slice for the mock call
	var mockArgs []interface{}
	mockArgs = append(mockArgs, repoPath)
	for _, arg := range args {
		mockArgs = append(mockArgs, arg)
	}

	// The Call method asserts that the expected arguments were passed,
	// and returns the values that you pre-programmed using .On()
	ret := m.Called(mockArgs...)

	// Extract return values
	// Index 0 is the []byte (output)
	output, _ := ret.Get(0).([]byte)
	// Index 1 is the error
	return output, ret.Error(1)
}
